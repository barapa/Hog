package front_end;
import java.util.*;
import java.io.*;
import java_cup.runtime.*;
import util.ast.node.*;
import util.type.*;

action code
  {:
    Hashtable table = new Hashtable();
  :};

parser code
  {:
    private Lexer lexer;
    private File file;
    public Parser( File file ) {
      this();
      this.file = file;
      try {
        lexer = new Lexer( new FileReader( file ) );
      }
      catch ( IOException exception ) {
        throw new Error( "Unable to open file \"" + file + "\"" );
      }
    }
  :};

scan with
  {:
    return lexer.next_token();
  :};

terminal DECR, INCR, RETURN, CONTINUE;
terminal TIMES, DIVIDE, MOD;
terminal LESS, GRTR, LESS_EQL, GRTR_EQL, DBL_EQLS, NOT_EQLS, ASSIGN;
terminal TEXT, BOOL, INT, REAL, LIST, VOID;
terminal MINUS, UMINUS, PLUS;
terminal ARROW, DOT;
terminal String CHAR;
terminal String TEXT_LITERAL;
terminal String ID;
terminal String INT_CONST;
terminal String REAL_CONST;
terminal String BOOL_CONST;
terminal BREAK, CASE, DEFAULT;
terminal AND, OR, NOT;
terminal WHILE, FOR, FOREACH, IN, IF, ELSE, ELSEIF, SWITCH;
terminal FUNCTIONS, MAIN, MAP, REDUCE;
terminal L_BRACE, R_BRACE, L_BRKT, R_BRKT, L_PAREN, R_PAREN, SEMICOL, COL, COMMA, NEWLINE;

nonterminal Program, Functions, FunctionList, Function, ParameterList, Map, Reduce, SectionType;
nonterminal Main, StatementList, ExpressionStatement, SelectionStatement, IterationStatement;
nonterminal LabeledStatement, LogicalExpression, LogicalTerm;
nonterminal EqualityExpression, RelationalExpression;
nonterminal Parameters;

nonterminal Statement, ElseIfStatement, ElseStatement;

nonterminal ExpressionNode Expression;
nonterminal ExpressionNode AdditiveExpression;
nonterminal ExpressionNode MultiplicativeExpression;
nonterminal ExpressionNode CastExpression;
nonterminal ExpressionNode UnaryExpression;
nonterminal ExpressionNode PostfixExpression;
nonterminal ExpressionNode PrimaryExpression;
nonterminal ExpressionNode Constant;
nonterminal Types.Type Type;
nonterminal UnOpNode.OpType UnaryOperator;

precedence left MINUS, PLUS;
precedence right UMINUS;

start with Program;

Program::=
    Functions Map Reduce Main
  ;

Functions::=
    FUNCTIONS L_BRACE FunctionList R_BRACE
  |
    /* epsilon */
  ; 
 
FunctionList::=
    Function
  |
    FunctionList Function
  ;

Function::=
    Type ID L_PAREN ParameterList R_PAREN L_BRACE StatementList R_BRACE
  ;

ParameterList::=
    Type ID COMMA ParameterList
  |
    Type ID
  |
    /* epsilon */
  ;

Map::=
    MAP SectionType L_BRACE StatementList R_BRACE
  ;

Reduce::=
    REDUCE SectionType L_BRACE StatementList R_BRACE
  ;

SectionType::=
    L_PAREN Type ID COMMA Type ID R_PAREN ARROW L_PAREN Type COMMA Type R_PAREN
  ;

Main::=
    MAIN L_BRACE StatementList R_BRACE
  ;

StatementList::=
    StatementList ExpressionStatement
  |
    StatementList SelectionStatement
  |
    StatementList IterationStatement
  |
    StatementList LabeledStatement
  |
    /* epsilon */
  |
    BREAK
  |
    CONTINUE
  |
    RETURN Expression
  ;
 
ExpressionStatement::=
    NEWLINE
  |
    Expression NEWLINE
  ;

Expression::=
    LogicalExpression
  |
    UnaryExpression ASSIGN Expression
  ;

LogicalExpression::=
    LogicalExpression OR LogicalTerm
  |
    LogicalTerm
  ;

LogicalTerm::=
    LogicalTerm AND EqualityExpression
  |
    EqualityExpression
  ;

EqualityExpression::=
    RelationalExpression
  |
    EqualityExpression DBL_EQLS RelationalExpression
  |
    EqualityExpression NOT_EQLS RelationalExpression
  ;

RelationalExpression::=
    AdditiveExpression
  |
    RelationalExpression LESS AdditiveExpression
  |
    RelationalExpression GRTR AdditiveExpression
  |
    RelationalExpression LESS_EQL AdditiveExpression
  |
    RelationalExpression GRTR_EQL AdditiveExpression
  ;

AdditiveExpression::=
    MultiplicativeExpression:me
  |
    AdditiveExpression PLUS MultiplicativeExpression
  |
    AdditiveExpression:ae MINUS MultiplicativeExpression:me
    {: 

    :}
  ;

MultiplicativeExpression::=
    CastExpression:c
    {:
      RESULT = c;
    :}
  |
    MultiplicativeExpression:m TIMES CastExpression:c
    {:
      RESULT = new MultiplicativeExpressionNode(BiOpNode.OpType.TIMES, m, c); 
    :}
  |
    MultiplicativeExpression:m DIVIDE CastExpression:c
    {:
      RESULT = new MultiplicativeExpressionNode(BiOpNode.OpType.DIVIDE, m, c);
    :}
  |
    MultiplicativeExpression:m MOD CastExpression:c
    {:
      RESULT = new MultiplicativeExpressionNode(BiOpNode.OpType.MOD, m, c);
    :}
  ;

CastExpression::=
    UnaryExpression:u
    {:
      RESULT = u;
    :}
  |
    L_PAREN Type R_PAREN CastExpression
    {:
      RESULT = new CastExpressionNode
    :}
  ;

UnaryExpression::=
    UnaryOperator:u CastExpression:c
    {:
      RESULT = new UnaryExpressionNode(c, u);
    :}
  |
    PostfixExpression:p
    {:
      RESULT = p;
    :}
  ;
  
UnaryOperator::=
    MINUS 
    {:
      RESULT = UnOpNode.OpType.UMINUS;
    :}
    %prec UMINUS
  |
    NOT
    {:
      RESULT = UnOpNode.OpType.NOT;
    :}
  ;

PostfixExpression::=
    PrimaryExpression:p
    {:
      RESULT = p;
    :}
  |
    PostfixExpression:p INCR
    {:
      RESULT = new PostfixExpressionNode(p, UnOpNode.OpType.INCR);
    :}
  |
    PostfixExpression:p DECR
    {:
      RESULT = new PostfixExpressionNode(p, UnOpNode.OpType.DECR);
    :}
  ;

PrimaryExpression::=
    ID:i
    {:
      RESULT = new IdNode(i);
    :}
  |
    ID DOT ID L_PAREN Parameters R_PAREN
  |
    Constant:c
    {:
      RESULT = c; 
    :}
  |
    L_PAREN Expression:e R_PAREN
    {:
      RESULT = e;
    :}
  ;

Parameters::=
    ID
  | 
    ID COMMA Parameters
  ;

Constant::=
    INT_CONST:i
    {:
      RESULT = new ConstantNode(Types.Type.INT, i);
    :}
  |
    REAL_CONST:d
    {:
      RESULT = new ConstantNode(Types.Type.REAL, d);
    :}
  |
    BOOL_CONST:b
    {:
      RESULT = new ConstantNode(Types.Type.BOOL, b);
    :}
  |
    TEXT_LITERAL:t
    {:
      RESULT = new ConstantNode(Types.Type.TEXT, t);
    :}
  ;

SelectionStatement::=
    IF L_PAREN Expression R_PAREN Statement ElseIfStatement ElseStatement
  |
    SWITCH L_PAREN Expression R_PAREN Statement
  ;

ElseIfStatement::=
    ELSEIF L_PAREN Expression R_PAREN ElseIfStatement
  |
    /* epsilon */
  ;

ElseStatement::=
    ELSE Statement
  |
    /* epsilon */
  ;

IterationStatement::=
    WHILE L_PAREN Expression R_PAREN Statement
  |
    FOR L_PAREN Expression SEMICOL Expression SEMICOL Expression R_PAREN Statement
  |
    FOREACH L_PAREN Expression IN Expression R_PAREN Statement
  ;
 
LabeledStatement::=
    CASE COL Statement
  |
    DEFAULT COL Statement 
  ;

Type::=
    VOID
    {:
      RESULT = Types.Type.VOID;
    :}
  |
    TEXT
    {:
      RESULT = Types.Type.TEXT;
    :}
  |
    BOOL
    {:
      RESULT = Types.Type.BOOL;
    :}
  |
    INT
    {:
      RESULT = Types.Type.INT;
    :}
  |
    REAL
    {:
      RESULT = Types.Type.REAL;
    :}
  ;