package front_end;
import java.util.*;
import java.io.*;
import java_cup.runtime.*;
import util.ast.node.*;
import util.type.*;

action code
  {:
    Hashtable table = new Hashtable();
  :};

parser code
  {:
    Lexer lexer;
    private File file;
    public Parser( File file ) {
      this();
      this.file = file;
      try {
        lexer = new Lexer( new FileReader( file ) );
      }
      catch ( IOException exception ) {
        throw new Error( "Unable to open file \"" + file + "\"" );
      }
    }
    
    public Parser(Lexer l) {
      super(l);
      lexer=l;
    }
  :};

scan with
  {:
    return lexer.next_token();
  :};

terminal DECR, INCR, RETURN, CONTINUE;
terminal TIMES, DIVIDE, MOD;
terminal LESS, GRTR, LESS_EQL, GRTR_EQL, DBL_EQLS, NOT_EQLS, ASSIGN;
terminal TEXT, BOOL, INT, REAL, VOID;
terminal MINUS, UMINUS, PLUS;
terminal ARROW, DOT;
terminal String TEXT_LITERAL;
terminal String ID;
terminal String INT_CONST;
terminal String REAL_CONST;
terminal String BOOL_CONST;
terminal String CASE;
terminal BREAK, DEFAULT;
terminal AND, OR, NOT;
terminal WHILE, FOR, FOREACH, IN, IF, ELSE, ELSEIF, SWITCH;
terminal FUNCTIONS, MAIN, MAP, REDUCE;
terminal L_BRACE, R_BRACE, L_BRKT, R_BRKT, L_PAREN, R_PAREN, SEMICOL, COL, COMMA, NEWLINE;
terminal LIST, ITER, DICT, MULTISET, SET;

nonterminal JumpStatement;
nonterminal ArgumentExpressionList;
nonterminal DerivedType;


nonterminal ProgramNode Program;
nonterminal SectionNode Functions;
nonterminal SectionNode Main;
nonterminal SectionNode Map;
nonterminal SectionNode Reduce;
nonterminal SectionTypeNode SectionType;
nonterminal StatementNode Statement;
nonterminal StatementNode ExpressionStatement;
nonterminal StatementNode FunctionList;
nonterminal StatementNode IterationStatement;
nonterminal StatementNode LabeledStatement;
nonterminal StatementNode SelectionStatement;
nonterminal StatementNode DeclarationStatement;
nonterminal StatementNode StatementList;
nonterminal SelectionStatementNode ElseIfStatement;
nonterminal SelectionStatementNode ElseStatement;
nonterminal ExpressionNode EqualityExpression;
nonterminal ExpressionNode LogicalExpression;
nonterminal ExpressionNode LogicalTerm;
nonterminal ExpressionNode RelationalExpression;
nonterminal ExpressionNode Expression;
nonterminal ExpressionNode AdditiveExpression;
nonterminal ExpressionNode MultiplicativeExpression;
nonterminal ExpressionNode CastExpression;
nonterminal ExpressionNode UnaryExpression;
nonterminal ExpressionNode PostfixExpression;
nonterminal ExpressionNode PrimaryExpression;
nonterminal ExpressionNode Constant;
nonterminal FunctionNode Function;
nonterminal ParametersNode ParameterList;
nonterminal Types.Type Type;
nonterminal UnOpNode.OpType UnaryOperator;

precedence left MINUS, PLUS;
precedence right UMINUS;
precedence right ELSE;
precedence right ELSEIF;
precedence right L_PAREN;

start with Program;

Program::=
    Functions:f NEWLINE Map:m NEWLINE Reduce:r NEWLINE Main:n NEWLINE
    {:
      RESULT = new ProgramNode(f, m, r, n);
      System.out.println("PROGRAM");
    :}
  ;

Functions::=
    FUNCTIONS L_BRACE FunctionList:fl NEWLINE R_BRACE
    {:
     RESULT = new SectionNode(fl);
     System.out.println("Functions -> FUNCTIONS L_BRACE FunctionList R_BRACE");
    :}
  |
    /* epsilon */
  ; 
 
FunctionList::=
    NEWLINE Function:f
    {:
      RESULT = f;
      System.out.println("FunctionList -> Function");
    :}
  |
    FunctionList:fl NEWLINE Function:f
    {:
      List<Node> children = new ArrayList<Node>();
      children.add(fl);
      children.add(f);
      RESULT = new StatementNode(children);
      System.out.println("FunctionList -> FunctionList Function");
    :}
  ;

Function::=
    Type:t ID L_PAREN ParameterList:pl R_PAREN L_BRACE StatementList:sl R_BRACE
    {:
      RESULT = new FunctionNode(t, pl, sl); 
      System.out.println("Function -> Type ID L_PAREN ParameterList R_PAREN L_BRACE StatementList R_BRACE");
    :}
  ;

ParameterList::=
    ParameterList:pl COMMA Type:t ID:i
    {:
      RESULT = new ParametersNode(t, i, pl);
      System.out.println("ParameterList -> ParameterList COMMA Type ID: " + i);
    :}
  |
    Type:t ID:i
    {:
      RESULT = new ParametersNode(t, i);
      System.out.println("ParameterList -> Type ID: " + i);
    :}
  |
    /* epsilon */
  ;

Map::=
    MAP SectionType:st L_BRACE StatementList:sl R_BRACE
    {:
      RESULT = new SectionNode(st, sl);
      System.out.println("Map -> MAP SectionType L_BRACE StatementList R_BRACE");
    :}
  ;

Reduce::=
    REDUCE SectionType:st L_BRACE StatementList:sl R_BRACE
    {:
      RESULT = new SectionNode(st, sl);
      System.out.println("Reduce -> REDUCE SectionType L_BRACE StatementList R_BRACE");
    :}
  ;

SectionType::=
    L_PAREN Type:t1 ID:i1 COMMA Type:t2 ID:i2 R_PAREN ARROW L_PAREN Type:t3 COMMA Type:t4 R_PAREN
    {:
     RESULT = new SectionTypeNode(new IdNode(i1, t1), new IdNode(i2, t2), t3, t4);
     System.out.println("SectionType -> L_PAREN Type ID COMMA Type ID R_PAREN ARROW L_PAREN Type COMMA Type R_PAREN");
    :}
  ;

Main::=
    MAIN L_BRACE StatementList:sl R_BRACE
    {:
      RESULT = new SectionNode(sl);
      System.out.println("Main -> MAIN L_BRACE StatementList R_BRACE");
    :}
  ;

StatementList::=
    NEWLINE Statement:s
    {:
      RESULT = s;
      System.out.println("StatementList -> Statement");
    :}
  |
    StatementList:sl NEWLINE Statement:s
    {:
      RESULT = new StatementNode(sl, s);
      System.out.println("StatementList -> StatementList Statement");
    :}
  ;

Statement::=
    ExpressionStatement:es
    {:
      RESULT = es;
      System.out.println("Statement -> ExpressionStatement");
    :}
  |
   SelectionStatement:ss
    {:
      RESULT = ss;
      System.out.println("Statement -> SelectionStatement");
    :}
  |
    IterationStatement:is
    {:
      RESULT = is;
      System.out.println("Statement -> IterationStatement");
    :}
  |
    LabeledStatement:ls
    {:
     //RESULT = ls;
     System.out.println("Statement -> LabeledStatement");
    :}
  |
    JumpStatement:js
    {:
      //RESULT = js;
      System.out.println("Statement -> JumpStatement");
    :}
  | DeclarationStatement:ds
    {:
      RESULT = ds;
      System.out.println("Statement -> DeclarationStatement");
    :}
  ;
 
DeclarationStatement::=
    Type:t ID:i
    {:
      RESULT = new IdNode(i, t);
      System.out.println("DeclarationStatement -> Type ID");
    :}
  |
    Type:t ID:i ASSIGN Expression:e
    {:
      RESULT = new BiOpNode(BiOpNode.OpType.ASSIGN, new IdNode(i,t), e);
      System.out.println("DeclarationStatement -> Type ID ASSIGN Expression");
    :}
  ;
 
JumpStatement::=
    CONTINUE
    {:
      System.out.println("JumpStatement -> CONTINUE NEWLINE");
    :}
  |
    BREAK
    {:
      System.out.println("JumpStatement -> BREAK NEWLINE");
    :}
  |
    RETURN ExpressionStatement
    {:
      System.out.println("JumpStatement -> RETURN Expression");
    :}
  ;
 
ExpressionStatement::=
    /* epsilon */
    {:
      /* TODO is this correct? */
      System.out.println("ExpressionStatement -> NEWLINE");
    :}
  |
    Expression:e
    {:
      RESULT = e;
      System.out.println("ExpressionStatement -> Expression NEWLINE");
    :}
  ;

Expression::=
    LogicalExpression:le
    {:
     RESULT = le;
     System.out.println("Expression -> LogicalExpression");
    :}
  |
    UnaryExpression:ue ASSIGN Expression:e
    {:
      RESULT = new BiOpNode(BiOpNode.OpType.ASSIGN, ue, e);
      System.out.println("Expression -> UnaryExpression ASSIGN Expression");
    :}
  ;

LogicalExpression::=
    LogicalExpression:le OR LogicalTerm:lt
    {:
      RESULT = new BiOpNode(BiOpNode.OpType.OR, le, lt);
      System.out.println("LogicalExpression -> LogicalExpression OR LogicalTerm");
    :}
  |
    LogicalTerm:l
    {:
      RESULT = l;
      System.out.println("LogicalExpression -> LogicalTerm");
    :}
  ;

LogicalTerm::=
    LogicalTerm:l AND EqualityExpression:e
    {:
      RESULT = new BiOpNode(BiOpNode.OpType.AND, l, e);
      System.out.println("LogicalTerm -> LogicalTerm AND EqualityExpression");
    :}
  |
    EqualityExpression:e
    {:
      RESULT = e;
      System.out.println("LogicalTerm -> EqualityExpression");
    :}
  ;

EqualityExpression::=
    RelationalExpression:r
    {: 
      RESULT = r; 
      System.out.println("EqualityExpression -> RelationalExpression");
    :}
  |
    EqualityExpression:e DBL_EQLS RelationalExpression:r
    {:
      RESULT = new BiOpNode(BiOpNode.OpType.DBL_EQLS, e, r);
      System.out.println("EqualityExpression -> EqualityExpression DBL_EQLS RelationalExpression");
    :}
  |
    EqualityExpression:e NOT_EQLS RelationalExpression:r
    {:
      RESULT = new BiOpNode(BiOpNode.OpType.NOT_EQLS, e, r);
      System.out.println("EqualityExpression -> EqualityExpression NOT_EQLS RelationalExpression");
    :}
  ;

RelationalExpression::=
    AdditiveExpression:a
    {:
      // RESULT = a;
      System.out.println("RelationalExpression -> AdditiveExpression");
    :}
  |
    RelationalExpression:r LESS AdditiveExpression:a
    {:
      // RESULT = new BiOpNode(BiOpNode.OpType.LESS, r, a);
      System.out.println("RelationalExpression -> RelationalExpression LESS AdditiveExpression");
    :}
  |
    RelationalExpression:r GRTR AdditiveExpression:a
    {:
      // RESULT = new BiOpNode(BiOpNode.OpType.GRTR, r, a);
      System.out.println("RelationalExpression -> RelationalExpression GRTR AdditiveExpression");
    :}
  |
    RelationalExpression:r LESS_EQL AdditiveExpression:a
    {:
      // RESULT = new BiOpNode(BiOpNode.OpType.LESS_EQL, r, a);
      System.out.println("RelationalExpression -> RelationalExpression LESS_EQL AdditiveExpression");
    :}
  |
    RelationalExpression:r GRTR_EQL AdditiveExpression:a
    {:
      // RESULT = new BiOpNode(BiOpNode.OpType.GRTR_EQL, r, a);
      System.out.println("RelationalExpression -> RelationalExpression GRTR_EQL AdditiveExpression");
    :}
  ;

AdditiveExpression::=
    MultiplicativeExpression:m
    {:
      // RESULT = m;
      System.out.println("AdditiveExpression -> MultiplicativeExpression");
    :}
  |
    AdditiveExpression:a PLUS MultiplicativeExpression:m
    {:
      // RESULT = new BiOpNode(BiOpNode.OpType.PLUS, a, m);
      System.out.println("AdditiveExpression -> AdditiveExpression PLUS MultiplicativeExpression");
    :}
  |
    AdditiveExpression:a MINUS MultiplicativeExpression:m
    {: 
      // RESULT = new BiOpNode(BiOpNode.OpType.MINUS, a, m);
      System.out.println("AdditiveExpression -> AdditiveExpression MINUS MultiplicativeExpression");
    :}
  ;

MultiplicativeExpression::=
    CastExpression:c
    {:
      // RESULT = c;
      System.out.println("MultiplicativeExpression -> CastExpression");
    :}
  |
    MultiplicativeExpression:m TIMES CastExpression:c
    {:
      // RESULT = new BiOpNode(BiOpNode.OpType.TIMES, m, c);
      System.out.println("MultiplicativeExpression -> MultiplicativeExpression TIMES CastExpression");
    :}
  |
    MultiplicativeExpression:m DIVIDE CastExpression:c
    {:
      // RESULT = new BiOpNode(BiOpNode.OpType.DIVIDE, m, c);
      System.out.println("MultiplicativeExpression -> MultiplicativeExpression DIVIDE CastExpression");
    :}
  |
    MultiplicativeExpression:m MOD CastExpression:c
    {:
      // RESULT = new BiOpNode(BiOpNode.OpType.MOD, m, c);
      System.out.println("MultiplicativeExpression -> MultiplicativeExpression MOD CastExpression");
    :}
  ;

CastExpression::=
    UnaryExpression:u
    {:
      // RESULT = u;
      System.out.println("CastExpression -> UnaryExpression");
    :}
  |
    L_PAREN Type:t R_PAREN CastExpression:c
    {:
      // RESULT = new UnOpNode(UnOpNode.OpType.CAST, c, t);
      System.out.println("CastExpression -> L_PAREN Type R_PAREN CastExpression");
    :}
  ;

UnaryExpression::=
    UnaryOperator:u CastExpression:c
    {:
      // RESULT = new UnOpNode(u, c);
      System.out.println("UnaryExpression -> UnaryOperator CastExpression");
    :}
  |
    PostfixExpression:p
    {:
      // RESULT = p;
      System.out.println("UnaryExpression -> PostfixExpression");
    :}
  ;
  
UnaryOperator::=
    MINUS 
    {:
      // RESULT = UnOpNode.OpType.UMINUS;
      System.out.println("UnaryOperator -> UMINUS");
    :}
    %prec UMINUS
  |
    NOT
    {:
      // RESULT = UnOpNode.OpType.NOT;
      System.out.println("UnaryOperator -> NOT");
    :}
  ;

PostfixExpression::=
    PrimaryExpression:p
    {:
      // RESULT = p;
      System.out.println("PostfixExpression -> PrimaryExpression");
    :}
  |
    PostfixExpression L_BRKT Expression R_BRKT
    {:
      System.out.println("PostfixExpression -> PostfixExpression L_BRKT Expression R_BRKT"); 
    :}
  |
    PostfixExpression DOT ID:i
    {:
      System.out.println("PostfixExpression -> PostfixExpression DOT ID: " + i); 
    :}
  |
    PostfixExpression L_PAREN R_PAREN
    {:
      System.out.println("PostfixExpression -> PostfixExpression L_PAREN R_PAREN"); 
    :}
  |
    PostfixExpression L_PAREN ArgumentExpressionList R_PAREN
    {:
      System.out.println("PostfixExpression -> PostfixExpression L_PAREN ArgumentExpressionList R_PAREN"); 
    :}
  |
    PostfixExpression:p INCR
    {:
      // RESULT = new UnOpNode(UnOpNode.OpType.INCR, p);
      System.out.println("PostfixExpression -> PostfixExpression INCR");
    :}
  |
    PostfixExpression:p DECR
    {:
      // RESULT = new UnOpNode(UnOpNode.OpType.DECR, p);
      System.out.println("PostfixExpression -> PostfixExpression DECR");
    :}
  ;

ArgumentExpressionList::=
    Expression
    {:
      System.out.println("ArgumentExpressionList -> Expression");
    :}
  |
    ArgumentExpressionList COMMA Expression
    {:
      System.out.println("ArgumentExpressionList -> ArgumentExpressionList COMMA Expression");
    :}
  ;

PrimaryExpression::=
    ID:i
    {:
      // RESULT = new IdNode(i);
      System.out.println("PrimaryExpression -> ID: " + i);
    :}
  |
    Constant:c
    {:
      // RESULT = c;
      System.out.println("PrimaryExpression -> Constant"); 
    :}
  |
    L_PAREN Expression:e R_PAREN
    {:
      // RESULT = e;
      System.out.println("PrimaryExpression -> L_PAREN Expression R_PAREN");
    :}
  ;

Constant::=
    INT_CONST:i
    {:
      // RESULT = new ConstantNode(Types.Type.INT, i);
      System.out.println("Constant -> INT_CONST: " + i);
    :}
  |
    REAL_CONST:d
    {:
      // RESULT = new ConstantNode(Types.Type.REAL, d);
      System.out.println("Constant -> REAL_CONST");
    :}
  |
    BOOL_CONST:b
    {:
      // RESULT = new ConstantNode(Types.Type.BOOL, b);
      System.out.println("Constant -> BOOL_CONST");
    :}
  |
    TEXT_LITERAL:t
    {:
      // RESULT = new ConstantNode(Types.Type.TEXT, t);
      System.out.println("Constant -> TEXT_LITERAL");
    :}
  ;

SelectionStatement::=
    IF Expression:e L_BRACE StatementList R_BRACE ElseIfStatement:elif ElseStatement:el
    {:
      // SelectionStatementNode elseIfAndElse = new SelectionStatementNode(elif.getCondition(), elif, el);
      // RESULT = new SelectionStatementNode(e, s, elseIfAndElse);
      System.out.println("SelectionStatement -> IF L_PAREN Expression R_PAREN Statement ElseIfStatement ElseStatement");
    :}
  |
    SWITCH Expression:e L_BRACE StatementList:s R_BRACE
    {:
      System.out.println("SelectionStatement -> SWITCH L_PAREN Expression R_PAREN Statement");
    :}
  ;

ElseIfStatement::=
    ELSEIF Expression:e L_BRACE StatementList ElseIfStatement:elif R_BRACE
    {:
      // RESULT = new SelectionStatementNode(e, elif, null);
      System.out.println("ElseIfStatement -> ELSEIF L_PAREN Expression R_PAREN ElseIfStatement");
    :}
  |
    /* epsilon */
    {:
      System.out.println("ElseIfStatement -> epsilon");
    :}
  ;

ElseStatement::=
    ELSE L_BRACE StatementList R_BRACE
    {:
      // RESULT = new SelectionStatementNode(null, s, null);
    :}
  |
    NEWLINE
    {:
      System.out.println("ElseStatement -> epsilon");
    :}
  ;

IterationStatement::=
    WHILE Expression L_BRACE StatementList:s R_BRACE
    {:
      System.out.println("WHILE L_PAREN Expression R_PAREN Statement");
    :}
  |
    FOR Expression SEMICOL Expression SEMICOL Expression L_BRACE StatementList R_BRACE
    {:
      System.out.println("FOR L_PAREN Expression SEMICOL Expression SEMICOL Expression R_PAREN Statement");
    :}
  |
    FOREACH Expression IN Expression L_BRACE StatementList R_BRACE
    {:
      System.out.println("FOREACH L_PAREN Expression IN Expression R_PAREN Statement"); 
    :}
  ;
 
LabeledStatement::=
    CASE LogicalExpression COL Statement:s
    {:
      System.out.println("CASE LogicalExpression COL Statement");
    :}
  |
    DEFAULT:d COL Statement:s
    {:
      System.out.println("DEFAULT COL Statement");
    :} 
  ;

Type::=
    VOID
    {:
      RESULT = Types.Type.VOID;
      System.out.println("Type -> VOID");
    :}
  |
    TEXT
    {:
      RESULT = Types.Type.TEXT;
      System.out.println("Type -> TEXT");
    :}
  |
    BOOL
    {:
      RESULT = Types.Type.BOOL;
      System.out.println("Type -> BOOL");
    :}
  |
    INT:i
    {:
      RESULT = Types.Type.INT;
      System.out.println("Type -> INT");
    :}
  |
    REAL
    {:
      RESULT = Types.Type.REAL;
      System.out.println("Type -> REAL");
    :}
  |
    DerivedType
    {:
      System.out.println("Type -> DerivedType");
    :}
  ;

DerivedType::=
    DerivedType LESS Type GRTR
    {:
      System.out.println("DerivedType -> DerivedType L_ANGLE Type R_ANGLE");
    :}
  |
    LIST
    {:
      System.out.println("DerivedType -> LIST");
    :}
  |
    ITER
    {:
      System.out.println("DerivedType -> ITER");
    :}
  |
    DICT
    {:
      System.out.println("DerivedType -> DICT");
    :}
  |
    MULTISET
    {:
      System.out.println("DerivedType -> MULTISET");
    :}
  |
    SET
    {:
      System.out.println("DerivedType -> SET");
    :}
  ;